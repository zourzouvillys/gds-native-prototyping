# Java Continuations

A source code processor which creates high performance (relative to manually created CompletableFuture) async continuation
based implementation of methods.

The benefits of this are significantly easier to read code, as developers write code using normal procedural semantics, adding just an annotation to
methods.

## Usage

To make an async version of a class, annotate it with @async:

```

  @async int plus(int a, int b) {
    return a + b;
  }

```

This results in an inner class being generated in the same scope as the method that implements a state machine for the class.  An example of the 
above generated method is shown below (however, note that for this example a generated version isn't beneficial). 

```

  public static final class async__something extends io.ewok.continuation.AbstractIntContinuation {

    private final int a;
    private final int b;

  	async__something(io.ewok.continuation.IntContinuationReceiver receiver, int a, int b) {
  	  super(receiver);
  	  this.a = a;
  	  this.b = b;
  	}
  
    protected boolean invoke() {
      return returnValue(a + b);
    }
  
  }
  

```

The calling API is like so:

```

  AtomicInt result = new AtomicInt();

  Continuation c = new async__something(result::set, a, b);

  c.resume();
  
  // in this case, we only have a single step so make sure we are actually done.
  assert c.ready();

  System.err.println(result.get());

```

## Parallel Execution


Parameter evaluation order and allowed parallel execution follows the rule java execution: a always happens before b.

However, there is an exception to this: Java does not define the order that it will call method invocation parameters.  The problem with this is 
defining how exceptions are handled when multiple async dispatches throw.  Automatically aggregating the exceptions would violate the principle of
least surprise.

Implementations must therefore use a stub method call that aggregates the exceptions:

```
final int val1;
final int val2;
try {
  parallel(
    val1 = a.func1(),
    val2= b.func2()
  );
}
catch (AggregateException ex) {
  return;
}
```

This will invoke func1 and func2 without waiting for the other to complete.  The method accepting the parameters will only be
dispatched once both have completed.

Up to 32 parameters can be dispatched together this way.  ewok uses a bitmap of expected parameters, with the parameters initially set to 1.  When a
value is provided the the async invocation, the bit is cleared.  The continuation state will only change when all bits are cleared.

If an exception is thrown by any of the async invocations, then 

## Tail Call Optimization

If an async function returns the result of a call to another async function, it is tail call optimized (TCO).


## Code Generation

An async state machine is generated by performing static code analysis of the original (blocking) method.  It performs a multi-stage pass:

- Lift any calls to async methods into a variable declaration, and replace the call site with a variable reference.
- Calculate states needed, dependencies, and possible forks.
- Move statements to state invocation method
- Generate receiveValue() handlers & state change table.
- Generate receiveException() handlers & state change tables.


### Concept

A method is broken up into a set of states.

Any call to an async function gets dispatched to it, passing the local context as the receiver to the async function.

Async methods which return a value while being dispatched rather than asynchronously result in execution continuing inline.

Local variables & initial parameters used between states get converted to fields in the continuation frame.
 
Tail call optimization is handled by jumping to the new target by indicating the new context to the caller.


### Loops

A loop statement with an async call in it needs to be lifted to a virtual instruction set.  The instructions can then be emitted either as 
source code in a virtual state machine table, or directly as bytecode.

```

while (xyz.pollasync()) {

  int flag = something.asyncfunc();

  if (flag < 0) {
    return;
  }

someLabel:
  do {
    for (int i = x.asyncget() ; (i < moo.asyncval()) || (i > moo.asynccheck()); ++i) {
      try {
        if (x == 2) {
          break someLabel;
        }
      }
      catch (Exception ex) {
        this.y = 2;
      }
      finally {
        this.x = 1;
      }
    }
      
  } while (d.asynccall(d.asyncval()));
  
label1:
  switch (flag) {
    case 1:
      asyncfunc();
      break label1;
    case 2:
      if (asyncfunc()) {
      }
      break;
    case 3:
      break;
  }

}

```

Lets examine each of them separately:

#### While Loop

- 
-
-



### Expressions

An expression may have multiple async calls in it:

```
if ((func1() || func2()) && func3()) {
 // ...
}
```

this gets written into stages, each one evaluating the async response and then jumping to the next step. we can't just substitute the calls for
variables and ensure they are populated, as in the above example, func2() only gets called if func1() is evaluated to true, and func3() only gets
evaluated if func1() or func2() return true.

So it becomes something like this:

```


switch (state) {

  case 1:
  	break;
  case 2:
  	break;
  case 3:

}


```


### State Calculations

Each async call creates at least one new state.  The state is entered immediately after dispatching the async call.

When a value is received from the async call, the state has an entry block which defines the statements to execute when the value is received.  it
can also optionally have an exceptional block, which defines the statements to execute if the async call threw an error instead.

 


